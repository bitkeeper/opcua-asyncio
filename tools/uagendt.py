'''
Generates from an xml node set a code lib that contains the imported datatype and enum definitions.
'''

import sys
import argparse
from dataclasses import dataclass
import logging
import asyncio
from pathlib import Path
from typing import Union, Set, Dict, List, Tuple, Optional
from datetime import datetime
from asyncua import ua, Server, Client, Node
from asyncua.common.structures104 import _recursive_parse, make_enum_code, make_structure_code, clean_name, _read_data_type_definition

logging.basicConfig(level=logging.INFO)
_logger = logging.getLogger('asyncua')


FILE_HEADER_TEMPLATE: str = """\"\"\"
DO NOT EDIT THIS FILE!
It is automatically generated from data type definitions.
Used nodeset file: {nodeset_file}

File creation Date: {datetime_stamp}
\"\"\"

# pylint: disable=invalid-name

from typing import List, Optional, Dict
from dataclasses import dataclass, field
from enum import IntEnum, IntFlag
from asyncua import ua, Server, Client
{code}
"""

GENERATED_CODE_TEMPLATE: str = """
{enums}
{datastructures}

class ObjectTypes:
    '''
    Helpers for easy accessing of the ObjectTypes NodeIds
    '''
{objecttypes}

async def register_extension_objects(server: Server | Client) -> None:

    '''
    Register datatype and enums and correct the namespace index if needed
    '''

    # To allow relocatable namespaces, lookup namespace indexes:
{nslut}
    # Correct namespace of DataTypes runtime mapping:
{nscorrections}

    # Register extension object (enums + structs):
{register}
"""


@dataclass
class CodeGenerationEnum:
    name: str
    code: str
    data_type: ua.NodeId


@dataclass
class CodeGenerationDataType:
    name: str
    code: str
    encoding_id: ua.NodeId
    data_type: ua.NodeId


def replace_ns_by_fake(node_id: ua.NodeId) -> str:
    nodeid_str = node_id.to_string()
    nodeid_str = f'ns={{_ns{node_id.NamespaceIndex}_}}'+nodeid_str[nodeid_str.find(';'):]
    return nodeid_str


async def generate_object_code(name: str, sdef: Union[ua.EnumDefinition, ua.StructureDefinition], data_type=Optional[ua.NodeId], enum: bool = False, option_set: bool = False, log_fail: bool = True) -> str:
    """
    generate Python code of enums or data structure
    return the code
    """
    if enum:
        code = make_enum_code(name, sdef, option_set)
    else:
        code = make_structure_code(data_type, name, sdef, log_error=log_fail)
    return code


async def generate_code_enums(server: Union["Server", "Client"], base_node: Optional[Node] = None, option_set: bool = False) -> dict[str, CodeGenerationEnum]:
    if base_node is None:
        base_node = server.nodes.enum_data_type
    new_enums: dict[str, CodeGenerationEnum] = {}
    for desc in await base_node.get_children_descriptions(refs=ua.ObjectIds.HasSubtype):
        name = clean_name(desc.BrowseName.Name)
        if hasattr(ua, name):
            continue
        _logger.info("Generate code Enum %s %s OptionSet=%s", desc.NodeId, name, option_set)
        edef = await _read_data_type_definition(server, desc)
        if not edef:
            continue

        code: str = await generate_object_code(name, edef, enum=True, option_set=option_set)
        new_enums[name] = CodeGenerationEnum(name=name, code=code, data_type=desc.NodeId)
    return new_enums


async def load_objecttypes(server: Server, node_ids: List[ua.NodeId]) -> Dict[str, ua.NodeId]:
    """ Search a list of node_ids and return the objectype in it.

    Args:
        server (Server): opc ua server to get nodes from
        node_ids (List[ua.NodeId]): the list of node ids to search the for object types

    Returns:
        Dict[str, ua.NodeId]: A dict with the objects types, the first is the name and the second one the nodeid
    """
    object_types = dict()
    for node_id in node_ids:
        node = server.get_node(node_id)
        if await node.read_node_class() == ua.NodeClass.ObjectType:
            node_type_name = (await node.read_display_name()).Text
            object_types[node_type_name] = node_id
    return object_types


async def generate_data_type_definitions(server: Union["Server", "Client"], base_node: Optional[Node] = None, overwrite_existing=False) -> Tuple[dict[str, CodeGenerationEnum], dict[str, CodeGenerationDataType]]:
    """
    Read DataTypeDefition attribute on all Structure  and Enumeration  defined
    on server and generate Python objects in ua namespace to be used to talk with server
    """
    new_enums: dict[str, CodeGenerationEnum] = await generate_code_enums(server)

    new_data_types: dict[str, CodeGenerationDataType] = {}

    if base_node is None:
        base_node = server.nodes.base_structure_type
    dtypes = []
    await _recursive_parse(server, base_node, dtypes, add_existing=overwrite_existing)

    # When data_types are used as fields `make_structure_code` expected them to exists, so use the existing functionality to do that.
    # But we have to wait untill this point else `generate_code_enums` and `_recursive_parse` will not find any new type to generate anymore.
    await server.load_data_type_definitions()
    dtypes.sort()
    for dts in dtypes:
        try:
            code: str = await generate_object_code(dts.name, dts.sdef, data_type=dts.data_type)
            new_data_types[dts.name] = CodeGenerationDataType(name=dts.name, code=code, data_type=dts.data_type, encoding_id=dts.encoding_id)
        except NotImplementedError:
            _logger.exception("Structure type %s not implemented", dts.sdef)
        except AttributeError:
            raise
        except RuntimeError:
            raise
    return new_enums, new_data_types


async def _generate_data_type_definition_code(new_enums: dict[str, CodeGenerationEnum], new_types: dict[str, CodeGenerationDataType], object_types) -> Tuple[str, str, str]:
    """_summary_

    Args:
        new_enums (dict[str, CodeGenerationEnum]): _description_
        new_types (dict[str, CodeGenerationDataType]): _description_
        object_types (_type_): _description_

    Returns:
        Tuple[str, str, str]: _description_
    """
    code_enums: str = ''
    code_types: str = ''

    # Handle enums definitions
    for key, generated_enum in new_enums.items():
        code_enums += generated_enum.code

    # Datatype add generate code bodies
    for key, cgdt in new_types.items():
        # code_types +=  cgdt.code.replace("    Encoding: ua.UInt32 = field(default=0, repr=False, init=False, compare=False)\n", "")
        # TODO: the default=0 should be fixed in the code generator itself, for now handle it local
        code_types += cgdt.code.replace('default=0,', 'default=ua.UInt32(0),')

    # Object Types
    code_object_types = ""
    for object_type_name, node_id in object_types.items():
        type_name = object_type_name.replace(' ', '')
        code_object_types += f'    {type_name}: ua.NodeId = ua.NodeId.from_string("{node_id.to_string()}")\n'

    new_items = list()
    new_items.extend(new_enums.keys())
    new_items.extend(new_types.keys())

    # Strip ua prefix if it concerns an local datatype or enum
    for key in new_items:
        code_types = code_types.replace(f'ua.{key}', key)

    # TODO: replace by dataclass
    return code_enums, code_types, code_object_types


async def _generate_register_extension_objects_function(new_enums: dict[str, CodeGenerationEnum],
                                                        new_types: dict[str, CodeGenerationDataType],
                                                        object_types: dict[str, ua.NodeId],
                                                        namespace_array: list[str]) -> tuple[str, str, str]:
    """Generate the implementation of the `register_extension_objects` function.
    That will make sure the correct namespace indexes are used and register the extension objects of Enums and Structures.

    Args:
        new_enums (dict[str, CodeGenerationEnum]): _description_
        new_types (dict[str, CodeGenerationDataType]): _description_
        object_types (dict[str, ua.NodeId]): _description_
        namespace_array (list[str]): _description_

    Returns:
        tuple[str, str, str]: returns as string the code of ns lut, ns index correction and registration code
    """
    code_nslut: str = ""
    code_register: str = ''
    code_nscorrections: str = ""
    # Namespace LUT
    used_namespace_indexes: set[int] = set()

    # Handle enums definitions
    for key, generated_enum in new_enums.items():
        data_type = generated_enum.data_type
        name = generated_enum.name
        used_namespace_indexes.add(generated_enum.data_type.NamespaceIndex)
        code_register += f'    ua.register_enum(\"{name}\", ua.NodeId.from_string(f\"{replace_ns_by_fake(data_type)}\"), {name})\n'

    code_register += '\n'
    # Update datatype node namespace indexes
    for key, cgdt in new_types.items():
        used_namespace_indexes.add(cgdt.data_type.NamespaceIndex)
        used_namespace_indexes.add(cgdt.encoding_id.NamespaceIndex)
        encoding_id: ua.NodeId = cgdt.encoding_id
        code_nscorrections += f'    {cgdt.name}.data_type = ua.NodeId.from_string(f\"{replace_ns_by_fake(cgdt.data_type)}\")\n'
        code_register += f'    ua.register_extension_object("{key}", ua.NodeId.from_string(\n        f"{replace_ns_by_fake(encoding_id)}"), {key}, {key}.data_type)\n'

    # code_register += '\n'
    for object_type_name, node_id in object_types.items():
        type_name = object_type_name.replace(' ', '')
        code_nscorrections += f'\n    ObjectTypes.{type_name} = ua.NodeId.from_string(f"{replace_ns_by_fake(node_id)}")'

    for ns_idx in used_namespace_indexes:
        code_nslut += f'    _ns{ns_idx}_: int = await server.get_namespace_index("{namespace_array[ns_idx]}")\n'

    # TODO: replace by dataclass
    return code_nslut, code_nscorrections, code_register


async def generate_data_type_code(server: Server, nodes) -> str:
    """Extract generated data definitions into a code string that can be used a import module.

    Args:
        server (ua.Server): local ua.Server to use for importing the xml and generating the data definitions.

    Returns:
        str: The generate code as a single string.
    """

    new_enums, new_types = await generate_data_type_definitions(server, None)
    object_types = await load_objecttypes(server, nodes)

    # ------------------------------- structure ----------------------------------
    code_enums, code_types, code_object_types = await _generate_data_type_definition_code(new_enums, new_types, object_types)

    # ------------------------ register_extension_objects ------------------------
    namespace_array = await server.get_namespace_array()
    code_nslut, code_nscorrections, code_register = await _generate_register_extension_objects_function(new_enums, new_types, object_types, namespace_array)

    # ------------------------ fill code templae ------------------------
    return GENERATED_CODE_TEMPLATE.format(enums=code_enums,
                                          datastructures=code_types,
                                          objecttypes=code_object_types,
                                          nslut=code_nslut,
                                          nscorrections=code_nscorrections,
                                          register=code_register)


async def main():
    parser = argparse.ArgumentParser(
        prog='uagendt',
        description='From an Ua xml nodeset generate extension object Python dataclasses ',
    )

    parser.add_argument('nodeset_file', help='UaNodeset XML input filename.', type=Path)
    parser.add_argument('output_file', help='Python output filename.', type=Path)

    args = parser.parse_args()

    nodeset_file = args.nodeset_file
    output_file = args.output_file

    if not nodeset_file.is_file():
        print(f'Error: UaNodeset XML file "{nodeset_file}" doesn\'t exists.')
        sys.exit(1)
    print(f'Input  : {nodeset_file}')
    print(f'Output : {output_file}')

    server = Server()
    await server.init()
    server.set_endpoint('opc.tcp://127.0.0.1:14841/freeopcua/server/')

    nodes = await server.import_xml(nodeset_file, strict_mode=False)
    print("\n")

    code: str = FILE_HEADER_TEMPLATE.format(nodeset_file=nodeset_file.name, datetime_stamp=datetime.now(), code=await generate_data_type_code(server, nodes))

    with output_file.open(mode="w") as f:
        f.write(code)


if __name__ == '__main__':
    asyncio.run(main())
